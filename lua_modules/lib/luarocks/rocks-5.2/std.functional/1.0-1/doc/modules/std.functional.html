<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>functional 1.0 Reference</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>functional 1.0</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
<li><a href="#Types">Types </a></li>
</ul>


<h2>Modules</h2>
<ul class="nowrap">
  <li><strong>std.functional</strong></li>
  <li><a href="../modules/std.functional.operator.html">std.functional.operator</a></li>
  <li><a href="../modules/std.functional.tuple.html">std.functional.tuple</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>std.functional</code></h1>
<p>Functional programming.</p>
<p> A selection of higher-order functions to enable a functional style of
 programming in Lua.</p>


<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#any">any (...)</a></td>
	<td class="summary">Call a series of functions until one returns non-nil.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#bind">bind (fn, argt)</a></td>
	<td class="summary">Partially apply a function.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#callable">callable (x)</a></td>
	<td class="summary">Identify callable types.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#case">case (with, branches)</a></td>
	<td class="summary">A rudimentary case statement.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#collect">collect ([ifn=std.npairs], ...)</a></td>
	<td class="summary">Collect the results of an iterator.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#compose">compose (...)</a></td>
	<td class="summary">Compose functions.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cond">cond (expr, branch, ...)</a></td>
	<td class="summary">A rudimentary condition-case statement.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#curry">curry (fn, n)</a></td>
	<td class="summary">Curry a function.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#filter">filter (pfn[, ifn=std.pairs], ...)</a></td>
	<td class="summary">Filter an iterator with a predicate.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#flatten">flatten (t)</a></td>
	<td class="summary">Flatten a nested table into a list.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#foldl">foldl (fn[, d=t[1], t)</a></td>
	<td class="summary">Fold a binary function left associatively.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#foldr">foldr (fn[, d=t[1], t)</a></td>
	<td class="summary">Fold a binary function right associatively.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#id">id (...)</a></td>
	<td class="summary">Identity function.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#ireverse">ireverse (t)</a></td>
	<td class="summary">Return a new sequence with element order reversed.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#lambda">lambda (s)</a></td>
	<td class="summary">Compile a lambda string into a Lua function.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#map">map (fn[, ifn=std.pairs], ...)</a></td>
	<td class="summary">Map a function over an iterator.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#map_with">map_with (fn, tt)</a></td>
	<td class="summary">Map a function over a table of argument lists.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#memoize">memoize (fn[, mnemonicfn=std.tostring])</a></td>
	<td class="summary">Memoize a function, by wrapping it in a functable.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#nop">nop ()</a></td>
	<td class="summary">No operation.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#product">product (...)</a></td>
	<td class="summary">Functional list product.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#reduce">reduce (fn, d[, ifn=std.pairs], ...)</a></td>
	<td class="summary">Fold a binary function into an iterator.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#shape">shape (dims, t)</a></td>
	<td class="summary">Shape a table according to a list of dimensions.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#zip">zip (tt)</a></td>
	<td class="summary">Zip a table of tables.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#zip_with">zip_with (fn, tt)</a></td>
	<td class="summary">Zip a list of tables together with a function.</td>
	</tr>
</table>
<h2><a href="#Types">Types </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#mnemonic">mnemonic (...)</a></td>
	<td class="summary">Signature of a <a href="../modules/std.functional.html#memoize">memoize</a> argument normalization callback function.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#predicate">predicate (...)</a></td>
	<td class="summary">Signature of a <a href="../modules/std.functional.html#filter">filter</a> predicate callback function.</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header "><a name="Functions"></a>Functions</h2>

    <dl class="function">
    <dt>
    <a name = "any"></a>
    <strong>any (...)</strong>
    </dt>
    <dd>
    Call a series of functions until one returns non-nil.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">...</span>
            <span class="types"><span class="type">func</span></span>
         functions to call
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">function</span></span>
        to call fn1 .. fnN until one returns non-nil.
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">old_object_type = any(std.object.<span class="global">type</span>, <span class="global">io</span>.<span class="global">type</span>, <span class="global">type</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "bind"></a>
    <strong>bind (fn, argt)</strong>
    </dt>
    <dd>
    Partially apply a function.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">fn</span>
            <span class="types"><span class="type">func</span></span>
         function to apply partially
        </li>
        <li><span class="parameter">argt</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         table of <em>fn</em> arguments to bind
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        function with <em>argt</em> arguments already bound
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">cube = bind(std.functional.operator.pow, {[<span class="number">2</span>] = <span class="number">3</span>})</pre>
    </ul>

</dd>
    <dt>
    <a name = "callable"></a>
    <strong>callable (x)</strong>
    </dt>
    <dd>
    Identify callable types.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
         an object or primitive
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        <code>true</code> if <em>x</em> can be called, otherwise <code>false</code>
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="keyword">if</span> callable(functable) <span class="keyword">then</span> functable(args) <span class="keyword">end</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "case"></a>
    <strong>case (with, branches)</strong>
    </dt>
    <dd>
    A rudimentary case statement.
 Match <em>with</em> against keys in <em>branches</em> table.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">with</span>
         expression to match
        </li>
        <li><span class="parameter">branches</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         map possible matches to functions
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>


<p> the value associated with a matching key, or the first non-key</p>
<pre><code>value if no key matches. Function or functable valued matches are
called using *with* as the sole argument, and the result of that call
returned; otherwise the matching value associated with the matching
key is returned directly; or else `nil` if there is no match and no
default.
</code></pre>

    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="../modules/std.functional.html#cond">cond</a>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="keyword">return</span> case(<span class="global">type</span>(object), {
   <span class="global">table</span>  = <span class="string">'table'</span>,
   <span class="global">string</span> = <span class="keyword">function</span>() <span class="keyword">return</span> <span class="string">'string'</span> <span class="keyword">end</span>,
            <span class="keyword">function</span>(s) <span class="global">error</span>(<span class="string">'unhandled type: '</span> .. s) <span class="keyword">end</span>,
})</pre>
    </ul>

</dd>
    <dt>
    <a name = "collect"></a>
    <strong>collect ([ifn=std.npairs], ...)</strong>
    </dt>
    <dd>
    Collect the results of an iterator.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ifn</span>
            <span class="types"><span class="type">func</span></span>
         iterator function
         (<em>default</em> std.npairs)
        </li>
        <li><span class="parameter">...</span>
         <em>ifn</em> arguments
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
        of results from running <em>ifn</em> on <em>args</em>
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="../modules/std.functional.html#filter">filter</a></li>
         <li><a href="../modules/std.functional.html#map">map</a></li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">--&gt; {'a', 'b', 'c'}
</span>collect {<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, x=<span class="number">1</span>, y=<span class="number">2</span>, z=<span class="number">5</span>}</pre>
    </ul>

</dd>
    <dt>
    <a name = "compose"></a>
    <strong>compose (...)</strong>
    </dt>
    <dd>
    Compose functions.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">...</span>
            <span class="types"><span class="type">func</span></span>
         functions to compose
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">function</span></span>
         composition of fnN .. fn1: note that this is the
 reverse of what you might expect, but means that code like:</p>

<pre><code> compose(function(x) return f(x) end,
                    function(x) return g(x) end))
</code></pre>

<p> can be read from top to bottom.
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">vpairs = compose(<span class="global">table</span>.invert, <span class="global">ipairs</span>)
<span class="keyword">for</span> v, i <span class="keyword">in</span> vpairs {<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>} <span class="keyword">do</span> process(v, i) <span class="keyword">end</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "cond"></a>
    <strong>cond (expr, branch, ...)</strong>
    </dt>
    <dd>
    A rudimentary condition-case statement.
 If <em>expr</em> is 'truthy' return <em>branch</em> if given, otherwise <em>expr</em>
 itself. If the return value is a function or functable, then call it
 with <em>expr</em> as the sole argument and return the result; otherwise
 return it explicitly.   If <em>expr</em> is 'falsey', then recurse with the
 first two arguments stripped.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">expr</span>
         a Lua expression
        </li>
        <li><span class="parameter">branch</span>

<p> a function, functable or value to use if <em>expr</em> is</p>
<pre><code>'truthy'
</code></pre>

        </li>
        <li><span class="parameter">...</span>
         additional arguments to retry if <em>expr</em> is 'falsey'
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <a href="../modules/std.functional.html#case">case</a>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">-- recursively calculate the nth triangular number
</span><span class="keyword">function</span> triangle(n)
   <span class="keyword">return</span> cond(
      n &lt;= <span class="number">0</span>, <span class="number">0</span>,
      n == <span class="number">1</span>, <span class="number">1</span>,
              <span class="keyword">function</span>() <span class="keyword">return</span> n + triangle(n - <span class="number">1</span>) <span class="keyword">end</span>)
<span class="keyword">end</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "curry"></a>
    <strong>curry (fn, n)</strong>
    </dt>
    <dd>
    Curry a function.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">fn</span>
            <span class="types"><span class="type">func</span></span>
         function to curry
        </li>
        <li><span class="parameter">n</span>
            <span class="types"><span class="type">int</span></span>
         number of arguments
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">function</span></span>
        curried version of <em>fn</em>
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">add = curry(<span class="keyword">function</span>(x, y) <span class="keyword">return</span> x + y <span class="keyword">end</span>, <span class="number">2</span>)
incr, decr = add(<span class="number">1</span>), add(-<span class="number">1</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "filter"></a>
    <strong>filter (pfn[, ifn=std.pairs], ...)</strong>
    </dt>
    <dd>
    Filter an iterator with a predicate.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">pfn</span>
            <span class="types"><a class="type" href="../modules/std.functional.html#predicate">predicate</a></span>
         predicate function
        </li>
        <li><span class="parameter">ifn</span>
            <span class="types"><span class="type">func</span></span>
         iterator function
         (<em>default</em> std.pairs)
        </li>
        <li><span class="parameter">...</span>
         iterator arguments
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
        elements e for which <code>pfn(e)</code> is not 'falsey'.
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="../modules/std.functional.html#collect">collect</a></li>
         <li><a href="../modules/std.functional.html#map">map</a></li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">--&gt; {2, 4}
</span>filter(lambda <span class="string">'|e|e%2==0'</span>, std.elems, {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>})</pre>
    </ul>

</dd>
    <dt>
    <a name = "flatten"></a>
    <strong>flatten (t)</strong>
    </dt>
    <dd>
    Flatten a nested table into a list.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">t</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         a table
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
        a list of all non-table elements of <em>t</em>
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">--&gt; {1, 2, 3, 4, 5}
</span>flatten {{<span class="number">1</span>, {{<span class="number">2</span>}, <span class="number">3</span>}, <span class="number">4</span>}, <span class="number">5</span>}</pre>
    </ul>

</dd>
    <dt>
    <a name = "foldl"></a>
    <strong>foldl (fn[, d=t[1], t)</strong>
    </dt>
    <dd>
    Fold a binary function left associatively.
 If parameter <em>d</em> is omitted, the first element of <em>t</em> is used,
 and <em>t</em> treated as if it had been passed without that element.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">fn</span>
            <span class="types"><span class="type">func</span></span>
         binary function
        </li>
        <li><span class="parameter">d</span>
         initial left-most argument
         (<em>default</em> t[1)
        </li>
        <li><span class="parameter">t</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         a table
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        result
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="../modules/std.functional.html#foldr">foldr</a></li>
         <li><a href="../modules/std.functional.html#reduce">reduce</a></li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">foldl(operator.quot, {<span class="number">10000</span>, <span class="number">100</span>, <span class="number">10</span>}) == (<span class="number">10000</span> / <span class="number">100</span>) / <span class="number">10</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "foldr"></a>
    <strong>foldr (fn[, d=t[1], t)</strong>
    </dt>
    <dd>
    Fold a binary function right associatively.
 If parameter <em>d</em> is omitted, the last element of <em>t</em> is used,
 and <em>t</em> treated as if it had been passed without that element.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">fn</span>
            <span class="types"><span class="type">func</span></span>
         binary function
        </li>
        <li><span class="parameter">d</span>
         initial right-most argument
         (<em>default</em> t[1)
        </li>
        <li><span class="parameter">t</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         a table
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        result
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="../modules/std.functional.html#foldl">foldl</a></li>
         <li><a href="../modules/std.functional.html#reduce">reduce</a></li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">foldr(operator.quot, {<span class="number">10000</span>, <span class="number">100</span>, <span class="number">10</span>}) == <span class="number">10000</span> / (<span class="number">100</span> / <span class="number">10</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "id"></a>
    <strong>id (...)</strong>
    </dt>
    <dd>
    Identity function.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">...</span>
         arguments
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        <em>arguments</em>
    </ol>




</dd>
    <dt>
    <a name = "ireverse"></a>
    <strong>ireverse (t)</strong>
    </dt>
    <dd>
    Return a new sequence with element order reversed. </p>

<p> Apart from the order of the elements returned, this function follows
 the same rules as <a href="https://www.lua.org/manual/5.1/manual.html#pdf-ipairs">ipairs</a> for determining first and last elements.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">t</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         a table
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>

<p>a new table with integer keyed elements in reverse</p>
<pre><code>order with respect to *t*
</code></pre>

    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="https://www.lua.org/manual/5.1/manual.html#pdf-ipairs">ipairs</a>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="keyword">local</span> rielems = compose(ireverse, std.ielems)
<span class="comment">--&gt; bar
</span><span class="comment">--&gt; foo
</span>map(<span class="global">print</span>, rielems, {<span class="string">'foo'</span>, <span class="string">'bar'</span>, [<span class="number">4</span>]=<span class="string">'baz'</span>, d=<span class="number">5</span>})</pre>
    </ul>

</dd>
    <dt>
    <a name = "lambda"></a>
    <strong>lambda (s)</strong>
    </dt>
    <dd>
    Compile a lambda string into a Lua function. </p>

<p> A valid lambda string takes one of the following forms:</p>

<pre><code>1. `'=expression'`: equivalent to `function(...) return expression end`
1. `'|args|expression'`: equivalent to `function(args) return expression end`
</code></pre>

<p> The first form (starting with <code>'='</code>) automatically assigns the first
 nine arguments to parameters <code>'_1'</code> through <code>'_9'</code> for use within the
 expression body.   The parameter <code>'_1'</code> is aliased to <code>'_'</code>, and if the
 first non-whitespace of the whole expression is <code>'_'</code>, then the
 leading <code>'='</code> can be omitted.</p>

<p> The results are memoized, so recompiling a previously compiled
 lambda string is extremely fast.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">s</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         a lambda string
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">functable</span></span>
        compiled lambda string, can be called like a function
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">-- The following are equivalent:
</span>lambda <span class="string">'= _1 &lt; _2'</span>
lambda <span class="string">'|a,b| a&lt;b'</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "map"></a>
    <strong>map (fn[, ifn=std.pairs], ...)</strong>
    </dt>
    <dd>
    Map a function over an iterator.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">fn</span>
            <span class="types"><span class="type">func</span></span>
         map function
        </li>
        <li><span class="parameter">ifn</span>
            <span class="types"><span class="type">func</span></span>
         iterator function
         (<em>default</em> std.pairs)
        </li>
        <li><span class="parameter">...</span>
         iterator arguments
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
        results
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="../modules/std.functional.html#filter">filter</a></li>
         <li><a href="../modules/std.functional.html#map_with">map_with</a></li>
         <li><a href="../modules/std.functional.html#zip">zip</a></li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">--&gt; {1, 4, 9, 16}
</span>map(lambda <span class="string">'=_1*_1'</span>, std.ielems, {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>})</pre>
    </ul>

</dd>
    <dt>
    <a name = "map_with"></a>
    <strong>map_with (fn, tt)</strong>
    </dt>
    <dd>
    Map a function over a table of argument lists.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">fn</span>
            <span class="types"><span class="type">func</span></span>
         map function
        </li>
        <li><span class="parameter">tt</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         a table of <em>fn</em> argument lists
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
        new table of <em>fn</em> results
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="../modules/std.functional.html#map">map</a></li>
         <li><a href="../modules/std.functional.html#zip_with">zip_with</a></li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">--&gt; {'123', '45'}, {a='123', b='45'}
</span>conc = bind(map_with, {lambda <span class="string">'|...|table.concat {...}'</span>})
conc {{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}, {<span class="number">4</span>, <span class="number">5</span>}}, conc {a={<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, x=<span class="string">'y'</span>}, b={<span class="number">4</span>, <span class="number">5</span>, z=<span class="number">6</span>}}</pre>
    </ul>

</dd>
    <dt>
    <a name = "memoize"></a>
    <strong>memoize (fn[, mnemonicfn=std.tostring])</strong>
    </dt>
    <dd>
    Memoize a function, by wrapping it in a functable. </p>

<p> To ensure that memoize always returns the same results for the same
 arguments, it passes arguments to <em>fn</em>. You can specify a more
 sophisticated function if memoize should handle complicated argument
 equivalencies.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">fn</span>
            <span class="types"><span class="type">func</span></span>
         pure function: a function with no side effects
        </li>
        <li><span class="parameter">mnemonicfn</span>
            <span class="types"><a class="type" href="../modules/std.functional.html#mnemonic">mnemonic</a></span>
         how to remember the arguments
         (<em>default</em> std.tostring)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">functable</span></span>
        memoized function
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="keyword">local</span> fast = memoize(<span class="keyword">function</span>(...) <span class="comment">--[[ slow code ]]</span> <span class="keyword">end</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "nop"></a>
    <strong>nop ()</strong>
    </dt>
    <dd>
    No operation.
 This function ignores all arguments, and returns no values.





    <h3>See also:</h3>
    <ul>
         <a href="../modules/std.functional.html#id">id</a>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="keyword">if</span> unsupported <span class="keyword">then</span> vtable[<span class="string">'memrmem'</span>] = nop <span class="keyword">end</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "product"></a>
    <strong>product (...)</strong>
    </dt>
    <dd>
    Functional list product. </p>

<p> Return a list of each combination possible by taking a single
 element from each of the argument lists.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">...</span>
         operands
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        result
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">--&gt; {'000', '001', '010', '011', '100', '101', '110', '111'}
</span>map(<span class="global">table</span>.concat, ielems, product({<span class="number">0</span>,<span class="number">1</span>}, {<span class="number">0</span>, <span class="number">1</span>}, {<span class="number">0</span>, <span class="number">1</span>}))</pre>
    </ul>

</dd>
    <dt>
    <a name = "reduce"></a>
    <strong>reduce (fn, d[, ifn=std.pairs], ...)</strong>
    </dt>
    <dd>
    Fold a binary function into an iterator.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">fn</span>
            <span class="types"><span class="type">func</span></span>
         reduce function
        </li>
        <li><span class="parameter">d</span>
         initial first argument
        </li>
        <li><span class="parameter">ifn</span>
            <span class="types"><span class="type">func</span></span>
         iterator function
         (<em>default</em> std.pairs)
        </li>
        <li><span class="parameter">...</span>
         iterator arguments
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        result
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="../modules/std.functional.html#foldl">foldl</a></li>
         <li><a href="../modules/std.functional.html#foldr">foldr</a></li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">--&gt; 2 ^ 3 ^ 4 ==&gt; 4096
</span>reduce(operator.pow, <span class="number">2</span>, std.ielems, {<span class="number">3</span>, <span class="number">4</span>})</pre>
    </ul>

</dd>
    <dt>
    <a name = "shape"></a>
    <strong>shape (dims, t)</strong>
    </dt>
    <dd>
    Shape a table according to a list of dimensions. </p>

<p> Dimensions are given outermost first and items from the original
 list are distributed breadth first; there may be one 0 indicating
 an indefinite number. Hence, <code>{0}</code> is a flat list,
 <code>{1}</code> is a singleton, <code>{2, 0}</code> is a list of
 two lists, and <code>{0, 2}</code> is a list of pairs.</p>

<p> Algorithm: turn shape into all positive numbers, calculating
 the zero if necessary and making sure there is at most one;
 recursively walk the shape, adding empty tables until the bottom
 level is reached at which point add table items instead, using a
 counter to walk the flattened original list.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">dims</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         table of dimensions <code>{d1, ..., dn}</code>
        </li>
        <li><span class="parameter">t</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         a table of elements
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        reshaped list
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">--&gt; {{'a', 'b'}, {'c', 'd'}, {'e', 'f'}}
</span>shape({<span class="number">3</span>, <span class="number">2</span>}, {<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>})</pre>
    </ul>

</dd>
    <dt>
    <a name = "zip"></a>
    <strong>zip (tt)</strong>
    </dt>
    <dd>
    Zip a table of tables.
 Make a new table, with lists of elements at the same index in the
 original table. This function is effectively its own inverse.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">tt</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         a table of tables
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>

<p>new table with lists of elements of the same key</p>
<pre><code>from *tt*
</code></pre>

    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="../modules/std.functional.html#map">map</a></li>
         <li><a href="../modules/std.functional.html#zip_with">zip_with</a></li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">--&gt; {{1, 3, 5}, {2, 4}}, {a={x=1, y=3, z=5}, b={x=2, y=4}}
</span>zip {{<span class="number">1</span>, <span class="number">2</span>}, {<span class="number">3</span>, <span class="number">4</span>}, {<span class="number">5</span>}}, zip {x={a=<span class="number">1</span>, b=<span class="number">2</span>}, y={a=<span class="number">3</span>, b=<span class="number">4</span>}, z={a=<span class="number">5</span>}}</pre>
    </ul>

</dd>
    <dt>
    <a name = "zip_with"></a>
    <strong>zip_with (fn, tt)</strong>
    </dt>
    <dd>
    Zip a list of tables together with a function.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">fn</span>
            <span class="types"><span class="type">function</span></span>
         function
        </li>
        <li><span class="parameter">tt</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         table of tables
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         a new table of results from calls to <em>fn</em> with arguments</p>
<pre><code>made from all elements the same key in the original tables; effectively
the 'columns' in a simple list
</code></pre>
<p> of lists.
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="../modules/std.functional.html#map_with">map_with</a></li>
         <li><a href="../modules/std.functional.html#zip">zip</a></li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">--&gt; {'135', '24'}, {a='1', b='25'}
</span>conc = bind(zip_with, {lambda <span class="string">'|...|table.concat {...}'</span>})
conc {{<span class="number">1</span>, <span class="number">2</span>}, {<span class="number">3</span>, <span class="number">4</span>}, {<span class="number">5</span>}}, conc {{a=<span class="number">1</span>, b=<span class="number">2</span>}, x={a=<span class="number">3</span>, b=<span class="number">4</span>}, {b=<span class="number">5</span>}}</pre>
    </ul>

</dd>
</dl>
    <h2 class="section-header "><a name="Types"></a>Types </h2>

    <dl class="function">
    <dt>
    <a name = "mnemonic"></a>
    <strong>mnemonic (...)</strong>
    </dt>
    <dd>
    Signature of a <a href="../modules/std.functional.html#memoize">memoize</a> argument normalization callback function.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">...</span>
         arguments
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        stable serialized arguments
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="keyword">local</span> mnemonic = <span class="keyword">function</span>(name, value, props) <span class="keyword">return</span> name <span class="keyword">end</span>
<span class="keyword">local</span> intern = memoize(mksymbol, mnemonic)</pre>
    </ul>

</dd>
    <dt>
    <a name = "predicate"></a>
    <strong>predicate (...)</strong>
    </dt>
    <dd>
    Signature of a <a href="../modules/std.functional.html#filter">filter</a> predicate callback function.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">...</span>
         arguments
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">boolean</span></span>

<p>'truthy' if the predicate condition succeeds,</p>
<pre><code>'falsey' otherwise
</code></pre>

    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="keyword">local</span> predicate = lambda <span class="string">'|k,v|type(v)=="string"'</span>
<span class="keyword">local</span> strvalues = filter(predicate, std.<span class="global">pairs</span>, {name=<span class="string">'Roberto'</span>, id=<span class="number">12345</span>})</pre>
    </ul>

</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2022-01-04 18:34:39 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
